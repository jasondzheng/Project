#!/usr/bin/python

import sys
import os
import re

JS_PATH = 'src'

CLIENT_PATH = 'src/testClient.html'
# Subtractive path to replace components in path
URL_BASE_PATH = '/' + CLIENT_PATH[:CLIENT_PATH.find('/')]

IGNORE_PATHS = [
	'src/demos/'
]

HTML_DELIMITER = '<!-- GENERATED BY CLIENT GEN -->'

def main():
	# Assemble a collection of sources
	sources = {}
	for (dirpath, dirs, files) in os.walk(JS_PATH):
		for file in files:
			if not file.endswith('.js'):
				continue
			ignored = False
			for ignorePath in IGNORE_PATHS:
				if file.startswith(ignorePath):
					ignored = True
					break
			if ignored:
				continue
			fullPath = os.path.join(dirpath, file)
			with open(fullPath, 'r') as fileHandle:
				fileSource = fileHandle.read()
			afters = re.findall(r'\/\/\s*#AFTER\s+([^\n]+)(?=\n|$)', fileSource)
			fullPath = fullPath.replace('\\', '/')
			sources[fullPath] = ({
				'path': fullPath,
				'afters': afters
			})
	print('Validating references...')
	for key in sources:
		for after in sources[key]['afters']:
			if after not in sources.keys():
				print('Error: missing file ' + after + ', referenced by ' + key)
				return
	print('Checking for circular dependencies...')
	for key in sources:
		if isCircular(sources, key, []):
			print('Error: circular dependency found at root ' + key)
			return
	print('Generating ordering...')
	pool = [key for key in sources]
	placed = []
	while len(pool) > 0:
		entry = pool.pop(0)
		readyForPlacement = True
		for after in sources[entry]['afters']:
			if after not in placed:
				readyForPlacement = False
				break
		if readyForPlacement:
			placed.append(entry)
		else:
			pool.append(entry)
	print('Modifying client...')
	with open(CLIENT_PATH, 'r') as f:
		clientSource = f.read()
	if clientSource.find(HTML_DELIMITER) != -1:
		delimiterIndex = clientSource.find(HTML_DELIMITER);
		newlineIndex = clientSource.rfind('\n', 0, delimiterIndex);
		tabCount = delimiterIndex - newlineIndex - 1
	else:
		delimiterIndex = clientSource.find('<head>');
		newlineIndex = clientSource.rfind('\n', 0, delimiterIndex);
		tabCount = delimiterIndex - newlineIndex
	scriptTags = '\t' * tabCount + HTML_DELIMITER + '\n'
	for entry in placed:
		scriptTags += ('\t' * tabCount + '<script src="' + 
				entry[len(URL_BASE_PATH):] + 
				'"></script>\n')
	scriptTags += '\t' * tabCount + HTML_DELIMITER + '\n'
	if clientSource.find(HTML_DELIMITER) != -1:
		endIndex = clientSource.find(HTML_DELIMITER, 
				delimiterIndex + len(HTML_DELIMITER) + 1)
		endIndex = clientSource.find('\n', endIndex) + 1;
		clientSource = (clientSource[0:newlineIndex + 1] + scriptTags + 
				clientSource[endIndex:])
	else:
		endIndex = clientSource.find('\n', delimiterIndex) + 1;
		clientSource = (clientSource[0:endIndex] + scriptTags + 
				clientSource[endIndex:])
	with open(CLIENT_PATH, 'w') as f:
		f.write(clientSource)
	print('Done modifying client.')
	
circularity = {}
	
def isCircular(sources, key, visited):
	if key in visited:
		circularity[key] = True
		return True
	elif key in circularity:
		return circularity[key]
	visited.append(key)
	result = False
	for after in sources[key]['afters']:
		if isCircular(sources, after, visited):
			result = True
			break
	visited.pop()
	circularity[key] = result
	return result
			

if __name__ == '__main__':
  main()